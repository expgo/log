// Code generated by https://github.com/expgo/ag DO NOT EDIT.
// Plugins:
//   - github.com/expgo/enum

package log

import (
	"errors"
	"fmt"
	"strings"
)

const (
	// ConsoleNo is a Console of type no.
	ConsoleNo Console = "no"
	// ConsoleStdout is a Console of type stdout.
	ConsoleStdout Console = "stdout"
	// ConsoleStderr is a Console of type stderr.
	ConsoleStderr Console = "stderr"
)

const (
	// LevelDebug is a Level of type Debug.
	LevelDebug Level = -1
	// LevelInfo is a Level of type Info.
	LevelInfo Level = 0
	// LevelWarn is a Level of type Warn.
	LevelWarn Level = 1
	// LevelError is a Level of type Error.
	LevelError Level = 2
	// LevelDpanic is a Level of type DPanic.
	LevelDpanic Level = 3
	// LevelPanic is a Level of type Panic.
	LevelPanic Level = 4
	// LevelFatal is a Level of type Fatal.
	LevelFatal Level = 5
)

var ErrInvalidConsole = errors.New("not a valid Console")

var _ConsoleNameMap = map[string]Console{
	"no":     ConsoleNo,
	"stdout": ConsoleStdout,
	"stderr": ConsoleStderr,
}

// Name is the attribute of Console.
func (x Console) Name() string {
	if v, ok := _ConsoleNameMap[string(x)]; ok {
		return string(v)
	}
	return fmt.Sprintf("Console(%s).Name", string(x))
}

// Val is the attribute of Console.
func (x Console) Val() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Console) IsValid() bool {
	_, ok := _ConsoleNameMap[string(x)]
	return ok
}

// String implements the Stringer interface.
func (x Console) String() string {
	return x.Name()
}

// ParseConsole converts a string to a Console.
func ParseConsole(value string) (Console, error) {
	if x, ok := _ConsoleNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _ConsoleNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return "", fmt.Errorf("%s is %w", value, ErrInvalidConsole)
}

// MarshalText implements the text marshaller method.
func (x Console) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Console) UnmarshalText(text []byte) error {
	val, err := ParseConsole(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}

var ErrInvalidLevel = errors.New("not a valid Level")

var _LevelName = "DebugInfoWarnErrorDPanicPanicFatal"

var _LevelMapName = map[Level]string{
	LevelDebug:  _LevelName[0:5],
	LevelInfo:   _LevelName[5:9],
	LevelWarn:   _LevelName[9:13],
	LevelError:  _LevelName[13:18],
	LevelDpanic: _LevelName[18:24],
	LevelPanic:  _LevelName[24:29],
	LevelFatal:  _LevelName[29:34],
}

// Name is the attribute of Level.
func (x Level) Name() string {
	if v, ok := _LevelMapName[x]; ok {
		return v
	}
	panic(ErrInvalidLevel)
}

// Val is the attribute of Level.
func (x Level) Val() int8 {
	if x.IsValid() {
		return int8(x)
	}
	panic(ErrInvalidLevel)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Level) IsValid() bool {
	_, ok := _LevelMapName[x]
	return ok
}

// String implements the Stringer interface.
func (x Level) String() string {
	return x.Name()
}

var _LevelNameMap = map[string]Level{
	_LevelName[0:5]:                    LevelDebug,
	strings.ToLower(_LevelName[0:5]):   LevelDebug,
	_LevelName[5:9]:                    LevelInfo,
	strings.ToLower(_LevelName[5:9]):   LevelInfo,
	_LevelName[9:13]:                   LevelWarn,
	strings.ToLower(_LevelName[9:13]):  LevelWarn,
	_LevelName[13:18]:                  LevelError,
	strings.ToLower(_LevelName[13:18]): LevelError,
	_LevelName[18:24]:                  LevelDpanic,
	strings.ToLower(_LevelName[18:24]): LevelDpanic,
	_LevelName[24:29]:                  LevelPanic,
	strings.ToLower(_LevelName[24:29]): LevelPanic,
	_LevelName[29:34]:                  LevelFatal,
	strings.ToLower(_LevelName[29:34]): LevelFatal,
}

// ParseLevel converts a string to a Level.
func ParseLevel(value string) (Level, error) {
	if x, ok := _LevelNameMap[value]; ok {
		return x, nil
	}
	if x, ok := _LevelNameMap[strings.ToLower(value)]; ok {
		return x, nil
	}
	return Level(0), fmt.Errorf("%s is %w", value, ErrInvalidLevel)
}

// MarshalText implements the text marshaller method.
func (x Level) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Level) UnmarshalText(text []byte) error {
	val, err := ParseLevel(string(text))
	if err != nil {
		return err
	}
	*x = val
	return nil
}
